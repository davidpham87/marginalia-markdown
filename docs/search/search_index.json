{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Materiala (mkdocs-material + marginalia) \u00b6 Experience to leverage marginalia parser and mkdocs-material to create documentation. Example: https://davidpham87.github.io/materiala/ Rationale \u00b6 I really liked calva.io website for documentation [I still use emacs+cider] , and I saw it was based mkdocs-material . Since then, I wanted to use it for my own documentation. We already have marginalia, codox and cljdoc, so this library does not add a lot, but I still wanted to have a nice UI for personal project and as a nice project. My only experience before with auto-documentation/literal programming was org-file, marginalia and codox. Quick start \u00b6 pip3 install mkdocs-material mkdocs-awesome-pages-plugin mkdir doc # save the output here # parse your src folder and generate the files into ./doc clojure -Sdeps '{:deps {materiala {:git/url \"https://github.com/davidpham87/materiala/\" :sha \"cc3a44f2f71994e794ea7f91d2525e6402e284d3\"}}}' -m materiala.core src mkdocs build # release, use `mkdocs serve` for dev cd doc && python3 -m http.server firefox localhost:8000 # or your most favorite browser (I use google-chrome) Installation \u00b6 Add the following dependency to your deps.edn materiala { :git/url \"https://github.com/davidpham87/materiala/\" :sha \"cc3a44f2f71994e794ea7f91d2525e6402e284d3\" } Change for the latest sha code, if required. Note the group-id and artifact-id of the package might change once I get enough money to buy a domain. Status \u00b6 Status: alpha , although I will follow spec-ulation to give my best to avoid breaking changes. I want to be a nice person, so I will make sure to not break your code. The biggest issue is the library leverages on marginalia's parser. Technical Solution \u00b6 Marginalia API was easier to leverage (and marginalia had a nice website), so the library is build on its parser. As alternative, codox (on which neanderthal and the uncomplicate ecosystem built their documentation) was also considered for usage and extension by coding a specific writer. However, most of the function codox writer are private and I did not want to depend on private api. Is it a good idea? \u00b6 Well... Smashing strings together and having a DSL for representing data definitively goes against Clojure's philosophy and main lessons. But for this particular problem, I just wanted to have some user friendly and searchable docs for my coworkers/friends and thanks to Lisp homoiconicity and Clojure simplicity, parsing is not too hard. For big open source libraries published on Clojars, I would still look at cljdoc . Extension \u00b6 See here for an example of extension. Commande line args \u00b6 clojure -m materiala.core -h -d, --dir DIR ./doc Directory into which the documentation will be written -f, --file FILE File into which the documentation will be written -n, --name NAME Project name - if not given will be taken from project.clj -v, --version VERSION Project version - if not given will be taken from project.clj -D, --desc DESC Project description - if not given will be taken from project.clj -a, --deps DEPS Project dependencies in the form <group1>:<artifact1>:<version1> ; <group2>... If not given will be taken from project.clj -m, --multi Generate each namespace documentation as a separate file -l, --leiningen Generate the documentation for a Leiningen project file. -e, --exclude EXCLUDE Exclude source file ( s ) from the document generation process <file1> ; <file2>... If not given will be taken from project.clj -h, --help Show this help I mainly copied marginalia options and adapted it to the newest version of clojure.tools.cli . Dependencies \u00b6 You will have to install the following python dependencies: pip3 install mkdocs-material mkdocs-awesome-pages-plugin Example mkdocs.yml \u00b6 Here is an example of mkdocs.yml file that could be used for a github repository. site_name : Materiala repo_url : https://github.com/davidpham87/materiala edit_uri : edit/master/doc repo_name : github docs_dir : doc site_dir : docs theme : name : material logo : images/logo.png palette : primary : red markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true - pymdownx.arithmatex - pymdownx.superfences - pymdownx.inlinehilite - pymdownx.details extra_javascript : # Math - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML plugins : - search # necessary for search to work - awesome-pages # automatic navigation See mkdocs-material and mkdocs for more detail. Examples \u00b6 Materiala , obviously. See also \u00b6 marginalia mkdocs-material codox cljdoc What's up with logo \u00b6 Well, I was too lazy to find a proper one, so I took the latex mathematical integral sign, which ( hopefully ) is still open source. Development \u00b6 Run a repl (add your cider deps as well) clojure -Adev Run the test (todo: create some specs and generate with test.check ) clojure -Atest TODO \u00b6 Create an option to copy codox/cljcdoc link to source code instead of showing the raw code directly. License \u00b6 Copyright (C) 2020 David Pham Distributed under the Eclipse Public License, the same as Clojure.","title":"Materiala (mkdocs-material + marginalia)"},{"location":"#materiala-mkdocs-material-marginalia","text":"Experience to leverage marginalia parser and mkdocs-material to create documentation. Example: https://davidpham87.github.io/materiala/","title":"Materiala (mkdocs-material + marginalia)"},{"location":"#rationale","text":"I really liked calva.io website for documentation [I still use emacs+cider] , and I saw it was based mkdocs-material . Since then, I wanted to use it for my own documentation. We already have marginalia, codox and cljdoc, so this library does not add a lot, but I still wanted to have a nice UI for personal project and as a nice project. My only experience before with auto-documentation/literal programming was org-file, marginalia and codox.","title":"Rationale"},{"location":"#quick-start","text":"pip3 install mkdocs-material mkdocs-awesome-pages-plugin mkdir doc # save the output here # parse your src folder and generate the files into ./doc clojure -Sdeps '{:deps {materiala {:git/url \"https://github.com/davidpham87/materiala/\" :sha \"cc3a44f2f71994e794ea7f91d2525e6402e284d3\"}}}' -m materiala.core src mkdocs build # release, use `mkdocs serve` for dev cd doc && python3 -m http.server firefox localhost:8000 # or your most favorite browser (I use google-chrome)","title":"Quick start"},{"location":"#installation","text":"Add the following dependency to your deps.edn materiala { :git/url \"https://github.com/davidpham87/materiala/\" :sha \"cc3a44f2f71994e794ea7f91d2525e6402e284d3\" } Change for the latest sha code, if required. Note the group-id and artifact-id of the package might change once I get enough money to buy a domain.","title":"Installation"},{"location":"#status","text":"Status: alpha , although I will follow spec-ulation to give my best to avoid breaking changes. I want to be a nice person, so I will make sure to not break your code. The biggest issue is the library leverages on marginalia's parser.","title":"Status"},{"location":"#technical-solution","text":"Marginalia API was easier to leverage (and marginalia had a nice website), so the library is build on its parser. As alternative, codox (on which neanderthal and the uncomplicate ecosystem built their documentation) was also considered for usage and extension by coding a specific writer. However, most of the function codox writer are private and I did not want to depend on private api.","title":"Technical Solution"},{"location":"#is-it-a-good-idea","text":"Well... Smashing strings together and having a DSL for representing data definitively goes against Clojure's philosophy and main lessons. But for this particular problem, I just wanted to have some user friendly and searchable docs for my coworkers/friends and thanks to Lisp homoiconicity and Clojure simplicity, parsing is not too hard. For big open source libraries published on Clojars, I would still look at cljdoc .","title":"Is it a good idea?"},{"location":"#extension","text":"See here for an example of extension.","title":"Extension"},{"location":"#commande-line-args","text":"clojure -m materiala.core -h -d, --dir DIR ./doc Directory into which the documentation will be written -f, --file FILE File into which the documentation will be written -n, --name NAME Project name - if not given will be taken from project.clj -v, --version VERSION Project version - if not given will be taken from project.clj -D, --desc DESC Project description - if not given will be taken from project.clj -a, --deps DEPS Project dependencies in the form <group1>:<artifact1>:<version1> ; <group2>... If not given will be taken from project.clj -m, --multi Generate each namespace documentation as a separate file -l, --leiningen Generate the documentation for a Leiningen project file. -e, --exclude EXCLUDE Exclude source file ( s ) from the document generation process <file1> ; <file2>... If not given will be taken from project.clj -h, --help Show this help I mainly copied marginalia options and adapted it to the newest version of clojure.tools.cli .","title":"Commande line args"},{"location":"#dependencies","text":"You will have to install the following python dependencies: pip3 install mkdocs-material mkdocs-awesome-pages-plugin","title":"Dependencies"},{"location":"#example-mkdocsyml","text":"Here is an example of mkdocs.yml file that could be used for a github repository. site_name : Materiala repo_url : https://github.com/davidpham87/materiala edit_uri : edit/master/doc repo_name : github docs_dir : doc site_dir : docs theme : name : material logo : images/logo.png palette : primary : red markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true - pymdownx.arithmatex - pymdownx.superfences - pymdownx.inlinehilite - pymdownx.details extra_javascript : # Math - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML plugins : - search # necessary for search to work - awesome-pages # automatic navigation See mkdocs-material and mkdocs for more detail.","title":"Example mkdocs.yml"},{"location":"#examples","text":"Materiala , obviously.","title":"Examples"},{"location":"#see-also","text":"marginalia mkdocs-material codox cljdoc","title":"See also"},{"location":"#whats-up-with-logo","text":"Well, I was too lazy to find a proper one, so I took the latex mathematical integral sign, which ( hopefully ) is still open source.","title":"What's up with logo"},{"location":"#development","text":"Run a repl (add your cider deps as well) clojure -Adev Run the test (todo: create some specs and generate with test.check ) clojure -Atest","title":"Development"},{"location":"#todo","text":"Create an option to copy codox/cljcdoc link to source code instead of showing the raw code directly.","title":"TODO"},{"location":"#license","text":"Copyright (C) 2020 David Pham Distributed under the Eclipse Public License, the same as Clojure.","title":"License"},{"location":"extension/","text":"Extension \u00b6 The idea of the rendering is to create the markdown string from the raw forms and dispatching on the verb of the form (after keywordization [is a real name?]) ( defmethod render-code-form :defmethod [{ :keys [ docstring raw forms valid-call method-value verb ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" method-value \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( render-valid-call valid-valid-call ) \"\\n\\n\" \"??? info \\\"(\" verb \")\\\"\\n\" ( code-block raw 4 ) \"\\n\" )) ( defmethod render-code-form :comment [{ :keys [ raw ] :as m }] ( str \"## Comment \\n\\n\" ( code-block raw 0 ) \"\\n\\n\" )) The common top level pattern is the (def-verb-symbol var-name [vector-of-args] & body) , which is default case render this case. However, the number of top level forms is infinite thanks the power of macros (e.g. re-frame's reg-event-fx ). For these case, you can: Make a pull request so that I include them in the codebase, if the top level form is common in Clojure (like comment ). Extend the multimethod materiala.markdown/render-code-form with your top level form and import them in your main file. Example \u00b6 For a raw form (defn hello [x] 3) , the render-code-form multimethod gets the following map as input { :forms ( defn hello [ x ] 3 ) :verb defn :var hello :raw \"(defn hello [x] 3)\" } (Note to self: nice place to make specs). Hence an example of extension is ;; in user/doc/extension.clj ( ns user.doc.extension ( :require [ materiala.markdown :as mm :refer ( render-code-form code-block )])) ;; re-frame reg-event-fx follow this pattern ;; (reg-event-fx ;; ::initialize ;; event-fx-fn) ;; (reg-event-fx ;; ::initialize ;; (fn [cofx [_ & args]])) ( defmethod render-code-form ::register [{ :keys [ raw forms ]}] ( str \"## Event: \" ( second forms ) \"\\n\\n\" ( if ( symbol? ( nth forms 2 )) ( str \"Dispatch-fn: \" ( nth forms 2 )) ;; here we could have a better rendering by leveraing the code as data ;; by showing how it the event can be called ( code-block raw 0 )) \"\\n\\n\" )) ;; no shortcut here, have to do it ( defmethod render-code-form :reg-sub [ m ] ( render-code-form ( assoc m :verb ::register ))) ( defmethod render-code-form :reg-event-fx [ m ] ( render-code-form ( assoc m :verb ::register ))) ;; in user/doc/ns.clj ( ns user.doc.ns ( :require [ materiala.core ] [ user.doc.extension ])) ( defn -main [ & args ] ( apply materiala.core/main args )) Then you can just call it (make sure materiala is on your classpath) clojure -m user.doc.ns src Limitation \u00b6 The default symbol or :default key are reserved because on how multimethod works.","title":"Extension"},{"location":"extension/#extension","text":"The idea of the rendering is to create the markdown string from the raw forms and dispatching on the verb of the form (after keywordization [is a real name?]) ( defmethod render-code-form :defmethod [{ :keys [ docstring raw forms valid-call method-value verb ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" method-value \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( render-valid-call valid-valid-call ) \"\\n\\n\" \"??? info \\\"(\" verb \")\\\"\\n\" ( code-block raw 4 ) \"\\n\" )) ( defmethod render-code-form :comment [{ :keys [ raw ] :as m }] ( str \"## Comment \\n\\n\" ( code-block raw 0 ) \"\\n\\n\" )) The common top level pattern is the (def-verb-symbol var-name [vector-of-args] & body) , which is default case render this case. However, the number of top level forms is infinite thanks the power of macros (e.g. re-frame's reg-event-fx ). For these case, you can: Make a pull request so that I include them in the codebase, if the top level form is common in Clojure (like comment ). Extend the multimethod materiala.markdown/render-code-form with your top level form and import them in your main file.","title":"Extension"},{"location":"extension/#example","text":"For a raw form (defn hello [x] 3) , the render-code-form multimethod gets the following map as input { :forms ( defn hello [ x ] 3 ) :verb defn :var hello :raw \"(defn hello [x] 3)\" } (Note to self: nice place to make specs). Hence an example of extension is ;; in user/doc/extension.clj ( ns user.doc.extension ( :require [ materiala.markdown :as mm :refer ( render-code-form code-block )])) ;; re-frame reg-event-fx follow this pattern ;; (reg-event-fx ;; ::initialize ;; event-fx-fn) ;; (reg-event-fx ;; ::initialize ;; (fn [cofx [_ & args]])) ( defmethod render-code-form ::register [{ :keys [ raw forms ]}] ( str \"## Event: \" ( second forms ) \"\\n\\n\" ( if ( symbol? ( nth forms 2 )) ( str \"Dispatch-fn: \" ( nth forms 2 )) ;; here we could have a better rendering by leveraing the code as data ;; by showing how it the event can be called ( code-block raw 0 )) \"\\n\\n\" )) ;; no shortcut here, have to do it ( defmethod render-code-form :reg-sub [ m ] ( render-code-form ( assoc m :verb ::register ))) ( defmethod render-code-form :reg-event-fx [ m ] ( render-code-form ( assoc m :verb ::register ))) ;; in user/doc/ns.clj ( ns user.doc.ns ( :require [ materiala.core ] [ user.doc.extension ])) ( defn -main [ & args ] ( apply materiala.core/main args )) Then you can just call it (make sure materiala is on your classpath) clojure -m user.doc.ns src","title":"Example"},{"location":"extension/#limitation","text":"The default symbol or :default key are reserved because on how multimethod works.","title":"Limitation"},{"location":"materiala/core/","text":"materiala.core \u00b6 Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\pi} = -1 $$ ( ns ) ( ns materiala.core \"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\\\pi} = -1 $$\" ( :require [ clojure.java.io :as io ] [ clojure.tools.cli :refer ( parse-opts )] [ clojure.string :as str ] [ marginalia.core :as mc ] [ materiala.markdown ] [ materiala.extensions.core ])) *docs* \u00b6 ( def ) ( def ^ { :dynamic true } *docs* \"./doc\" ) cli-opts \u00b6 ( def ) ( def cli-opts [[ \"-d\" \"--dir DIR\" \"Directory into which the documentation will be written\" :default \"./doc\" ] [ \"-f\" \"--file FILE\" \"File into which the documentation will be written\" ] [ \"-n\" \"--name NAME\" \"Project name - if not given will be taken from project.clj\" ] [ \"-v\" \"--version VERSION\" \"Project version - if not given will be taken from project.clj\" ] [ \"-D\" \"--desc DESC\" \"Project description - if not given will be taken from project.clj\" ] [ \"-a\" \"--deps DEPS\" \"Project dependencies in the form <group1>:<artifact1>:<version1>;<group2>... If not given will be taken from project.clj\" ] [ \"-m\" \"--multi\" \"Generate each namespace documentation as a separate file\" :default true ] [ \"-l\" \"--leiningen\" \"Generate the documentation for a Leiningen project file.\" ] [ \"-e\" \"--exclude EXCLUDE\" \"Exclude source file(s) from the document generation process <file1>;<file2>... If not given will be taken from project.clj\" ] [ \"-h\" \"--help\" \"Show this help\" ]]) run-materiala \u00b6 Default generation: given a collection of filepaths in a project, find the .clj files at these paths and, if Clojure source files are found: Print out a message to std out letting a user know which files are to be processed; Create the docs directory inside the project folder if it doesn't already exist; Call the uberdoc! function to generate the output file at its default location, using the found source files and a project file expected to be in its default location. If no source files are found, complain with a usage message. ( run-materiala & args ) ( defn ) ( defn run-materiala [ & args ] ( let [ user-parsed-options ( parse-opts args cli-opts ) { :keys [ dir file name version desc deps multi leiningen exclude help ]} ( :options user-parsed-options ) files ( :arguments user-parsed-options ) sources ( distinct ( mc/format-sources ( seq files ))) sources ( if leiningen ( cons leiningen sources ) sources )] ( when help ( println ( :summary user-parsed-options ))) ( if ( and sources ( not help )) ( binding [ *docs* ( str/trim dir )] ( let [ project-clj ( when ( .exists ( io/file \"project.clj\" )) ( mc/parse-project-file )) choose # ( or %1 %2 ) marg-opts ( merge-with choose { :exclude ( when exclude ( .split exclude \";\" )) :leiningen leiningen } ( :marginalia project-clj )) opts ( merge-with choose { :name name :version version :description desc :dependencies ( mc/split-deps deps ) :multi multi :marginalia marg-opts } project-clj ) sources ( ->> sources ( filter # ( not ( mc/source-excluded? % opts ))) ( into []))] ( println \"Generating Marginalia documentation for the following source files:\" ) ( doseq [ s sources ] ( println \" \" s )) ( println ) ( mc/ensure-directory! *docs* ) ( if multi ( materiala.markdown/multidoc! *docs* sources opts ) ( materiala.markdown/uberdoc! ( str *docs* \"/\" file ) sources opts )) ( println \"Done generating your documentation in\" *docs* ) ( println \"\" ))) ( when-not help ( println \"Wrong number of arguments passed to Marginalia.\" ) ( println ( :summary user-parsed-options )))))) -main \u00b6 ( -main & args ) ( defn ) ( defn -main [ & args ] ( apply run-materiala args ))","title":"materiala.core"},{"location":"materiala/core/#materialacore","text":"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\pi} = -1 $$ ( ns ) ( ns materiala.core \"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\\\pi} = -1 $$\" ( :require [ clojure.java.io :as io ] [ clojure.tools.cli :refer ( parse-opts )] [ clojure.string :as str ] [ marginalia.core :as mc ] [ materiala.markdown ] [ materiala.extensions.core ]))","title":"materiala.core"},{"location":"materiala/core/#docs","text":"( def ) ( def ^ { :dynamic true } *docs* \"./doc\" )","title":"*docs*"},{"location":"materiala/core/#cli-opts","text":"( def ) ( def cli-opts [[ \"-d\" \"--dir DIR\" \"Directory into which the documentation will be written\" :default \"./doc\" ] [ \"-f\" \"--file FILE\" \"File into which the documentation will be written\" ] [ \"-n\" \"--name NAME\" \"Project name - if not given will be taken from project.clj\" ] [ \"-v\" \"--version VERSION\" \"Project version - if not given will be taken from project.clj\" ] [ \"-D\" \"--desc DESC\" \"Project description - if not given will be taken from project.clj\" ] [ \"-a\" \"--deps DEPS\" \"Project dependencies in the form <group1>:<artifact1>:<version1>;<group2>... If not given will be taken from project.clj\" ] [ \"-m\" \"--multi\" \"Generate each namespace documentation as a separate file\" :default true ] [ \"-l\" \"--leiningen\" \"Generate the documentation for a Leiningen project file.\" ] [ \"-e\" \"--exclude EXCLUDE\" \"Exclude source file(s) from the document generation process <file1>;<file2>... If not given will be taken from project.clj\" ] [ \"-h\" \"--help\" \"Show this help\" ]])","title":"cli-opts"},{"location":"materiala/core/#run-materiala","text":"Default generation: given a collection of filepaths in a project, find the .clj files at these paths and, if Clojure source files are found: Print out a message to std out letting a user know which files are to be processed; Create the docs directory inside the project folder if it doesn't already exist; Call the uberdoc! function to generate the output file at its default location, using the found source files and a project file expected to be in its default location. If no source files are found, complain with a usage message. ( run-materiala & args ) ( defn ) ( defn run-materiala [ & args ] ( let [ user-parsed-options ( parse-opts args cli-opts ) { :keys [ dir file name version desc deps multi leiningen exclude help ]} ( :options user-parsed-options ) files ( :arguments user-parsed-options ) sources ( distinct ( mc/format-sources ( seq files ))) sources ( if leiningen ( cons leiningen sources ) sources )] ( when help ( println ( :summary user-parsed-options ))) ( if ( and sources ( not help )) ( binding [ *docs* ( str/trim dir )] ( let [ project-clj ( when ( .exists ( io/file \"project.clj\" )) ( mc/parse-project-file )) choose # ( or %1 %2 ) marg-opts ( merge-with choose { :exclude ( when exclude ( .split exclude \";\" )) :leiningen leiningen } ( :marginalia project-clj )) opts ( merge-with choose { :name name :version version :description desc :dependencies ( mc/split-deps deps ) :multi multi :marginalia marg-opts } project-clj ) sources ( ->> sources ( filter # ( not ( mc/source-excluded? % opts ))) ( into []))] ( println \"Generating Marginalia documentation for the following source files:\" ) ( doseq [ s sources ] ( println \" \" s )) ( println ) ( mc/ensure-directory! *docs* ) ( if multi ( materiala.markdown/multidoc! *docs* sources opts ) ( materiala.markdown/uberdoc! ( str *docs* \"/\" file ) sources opts )) ( println \"Done generating your documentation in\" *docs* ) ( println \"\" ))) ( when-not help ( println \"Wrong number of arguments passed to Marginalia.\" ) ( println ( :summary user-parsed-options ))))))","title":"run-materiala"},{"location":"materiala/core/#-main","text":"( -main & args ) ( defn ) ( defn -main [ & args ] ( apply run-materiala args ))","title":"-main"},{"location":"materiala/markdown-test/","text":"materiala.markdown-test \u00b6 ( ns ) ( ns materiala.markdown-test ( :require [ materiala.markdown :as sut ] [ clojure.test :as t :refer ( deftest is are )])) intent \u00b6 ( deftest ) ( deftest intent ( are [ x s level ] ( = x ( sut/indent s level )) \"a\" \"a\" 0 \" a\" \"a\" 1 \" a\" \"a\" 2 \" a\\n b\" \"a\\nb\" 2 )) code-block \u00b6 ( deftest ) ( deftest code-block ( are [ s code indent ] ( = s ( sut/code-block code indent )) \"```clojure\\nx\\n```\" 'x 0 \" ```clojure\\n x\\n ```\" 'x 4 )) function-forms \u00b6 ( deftest ) ( deftest function-forms ( are [ calling-forms function-symbol fn-tail ] ( = calling-forms ( apply sut/function-forms function-symbol fn-tail )) ' [( f x y ) ( f x )] 'f ' [([ x y ] 3 ) ([ x ] 3 )] ' [( f x ) ( f x y )] 'f ' [([ x ] 3 ) ([ x y ] 3 )] ' [( f x ) ( f x & args )] 'f ' [([ x ] 3 ) ([ x & args ] 3 )])) raw->forms \u00b6 ( deftest ) ( deftest raw->forms ( are [ code-string result ] ( = result ( sut/raw->forms code-string )) \"(def hello 3)\" ' { :forms ( def hello 3 ) :verb def :var hello } \"(defn hello [x] 3)\" ' { :forms ( defn hello [ x ] 3 ) :verb defn :var hello :valid-call [( hello x )]} \"(defn hello ([x] 3) ([x y] 3))\" ' { :forms ( defn hello ([ x ] 3 ) ([ x y ] 3 )) :verb defn :var hello :valid-call [( hello x ) ( hello x y )]} \"(defmethod hello 3 [{:keys [a b]}] 3)\" ' { :forms ( defmethod hello 3 [{ :keys [ a b ]}] 3 ) :verb defmethod :var hello :valid-call [( hello { :keys [ a b ]})] :method-value 3 } \"(defn hello {:pre (constantly true)} ([m] 3))\" ' { :forms ( defn hello { :pre ( constantly true )} ([ m ] 3 )) , :verb defn , :var hello , :valid-call [( hello m )]} \"(reg-sub :hello (fn [m] 3))\" ' { :forms ( reg-sub :hello ( fn [ m ] 3 )) , :verb reg-sub , :var :hello })) add test with malformed code.","title":"materiala.markdown-test"},{"location":"materiala/markdown-test/#materialamarkdown-test","text":"( ns ) ( ns materiala.markdown-test ( :require [ materiala.markdown :as sut ] [ clojure.test :as t :refer ( deftest is are )]))","title":"materiala.markdown-test"},{"location":"materiala/markdown-test/#intent","text":"( deftest ) ( deftest intent ( are [ x s level ] ( = x ( sut/indent s level )) \"a\" \"a\" 0 \" a\" \"a\" 1 \" a\" \"a\" 2 \" a\\n b\" \"a\\nb\" 2 ))","title":"intent"},{"location":"materiala/markdown-test/#code-block","text":"( deftest ) ( deftest code-block ( are [ s code indent ] ( = s ( sut/code-block code indent )) \"```clojure\\nx\\n```\" 'x 0 \" ```clojure\\n x\\n ```\" 'x 4 ))","title":"code-block"},{"location":"materiala/markdown-test/#function-forms","text":"( deftest ) ( deftest function-forms ( are [ calling-forms function-symbol fn-tail ] ( = calling-forms ( apply sut/function-forms function-symbol fn-tail )) ' [( f x y ) ( f x )] 'f ' [([ x y ] 3 ) ([ x ] 3 )] ' [( f x ) ( f x y )] 'f ' [([ x ] 3 ) ([ x y ] 3 )] ' [( f x ) ( f x & args )] 'f ' [([ x ] 3 ) ([ x & args ] 3 )]))","title":"function-forms"},{"location":"materiala/markdown-test/#raw-forms","text":"( deftest ) ( deftest raw->forms ( are [ code-string result ] ( = result ( sut/raw->forms code-string )) \"(def hello 3)\" ' { :forms ( def hello 3 ) :verb def :var hello } \"(defn hello [x] 3)\" ' { :forms ( defn hello [ x ] 3 ) :verb defn :var hello :valid-call [( hello x )]} \"(defn hello ([x] 3) ([x y] 3))\" ' { :forms ( defn hello ([ x ] 3 ) ([ x y ] 3 )) :verb defn :var hello :valid-call [( hello x ) ( hello x y )]} \"(defmethod hello 3 [{:keys [a b]}] 3)\" ' { :forms ( defmethod hello 3 [{ :keys [ a b ]}] 3 ) :verb defmethod :var hello :valid-call [( hello { :keys [ a b ]})] :method-value 3 } \"(defn hello {:pre (constantly true)} ([m] 3))\" ' { :forms ( defn hello { :pre ( constantly true )} ([ m ] 3 )) , :verb defn , :var hello , :valid-call [( hello m )]} \"(reg-sub :hello (fn [m] 3))\" ' { :forms ( reg-sub :hello ( fn [ m ] 3 )) , :verb reg-sub , :var :hello })) add test with malformed code.","title":"raw-&gt;forms"},{"location":"materiala/markdown/","text":"materiala.markdown \u00b6 Utilities for parsing code into markdown ( ns ) ( ns materiala.markdown ( :require [ clojure.java.io ] [ clojure.string :as str ] [ clojure.edn ] [ clojure.tools.reader ] [ marginalia.parser :as p ])) drop-at \u00b6 Helper function to work with indices. Drop element from coll at indices idx . ( drop-at idx coll ) ( defn ) ( defn drop-at [ idx coll ] ( let [ n ( count coll ) idx ( sort ( if ( sequential? idx ) idx [ idx ]))] ( loop [ indices idx iteration 0 v coll ] ( if ( and ( seq indices ) ( < iteration n )) ( let [ i ( - ( first indices ) iteration ) v ( vec v )] ( recur ( rest indices ) ( inc iteration ) ( concat ( subvec v 0 i ) ( subvec v ( inc i ))))) ( vec v ))))) path-to-doc \u00b6 ( path-to-doc fn ) ( defn ) ( defn path-to-doc [ fn ] { :ns ( p/parse-ns ( java.io.File. fn )) :groups ( p/parse-file fn )}) indent \u00b6 Indent string portion ( indent s indent-level ) ( defn ) ( defn indent [ s indent-level ] ( let [ indent-space ( str/join \"\" ( repeat indent-level \" \" ))] ( str/join \"\\n\" ( map # ( str indent-space % ) ( str/split s # \"\\n\" ))))) code-block \u00b6 Create code block from given string s ( code-block s ) ( code-block s indent-level ) ( defn ) ( defn code-block ([ s ] ( code-block s 4 )) ([ s indent-level ] ( indent ( str \"```clojure\\n\" s \"\\n\" \"```\\n\\n\" ) indent-level ))) admonition \u00b6 Parsing error The displayed code is not valid. This is due to Marginalia's parsing code. ( defn ) ( defn admonition [{ :keys [ content type optional open title ] :or { optional false open false }}] ( str ( cond ( not optional ) \"!!! \" ( and optional open ) \"???+\" :else \"??? \" ) type \" \" ( when title ( str \" \\ title \" \\) ) \"\\n\\n\" ( indent content 4 ))) code-inline \u00b6 ( code-inline s ) ( defn ) ( defn code-inline [ s ] ( str \"`\" s \"`\" )) render-valid-call \u00b6 ( render-valid-call valid-call ) ( defn ) ( defn render-valid-call [ valid-call ] ( when valid-call ( -> ( str/join \"\\n\" ( map str valid-call )) ( str/replace # \",\" ) ( code-block 0 )))) render-def-form \u00b6 ( render-def-form { :keys [ docstring raw forms level verb valid-call ] :or { level 2 }}) ( defn ) ( defn render-def-form [{ :keys [ docstring raw forms level verb valid-call ] :or { level 2 }}] ( str ( str/join ( repeat level \"#\" )) \" \" ( case verb 'ns ( second forms ) ( code-inline ( second forms ))) ;; keep the ear-muff variable to get md rendered \"\\n\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( render-valid-call valid-call ) \"\\n\\n\" ( admonition { :content ( code-block raw 0 ) :type \"tip\" :title ( str \"(\" ( code-inline verb ) \")\" ) :optional true }) \"\\n\\n\" )) render-code-form \u00b6 ( defmulti ) ( defmulti render-code-form ( fn [ m ] ( -> m :verb keyword ))) render-code-form :default \u00b6 ( render-code-form { :keys [ docstring raw forms valid-call ] :as m }) ( defmethod ) ( defmethod render-code-form :default [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m )) render-code-form :ns \u00b6 ( render-code-form { :keys [ docstring raw forms valid-call ] :as m }) ( defmethod ) ( defmethod render-code-form :ns [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form ( assoc m :level 1 ))) render-code-form :defmethod \u00b6 ( render-code-form { :keys [ docstring raw forms valid-call method-value verb ] :as m }) ( defmethod ) ( defmethod render-code-form :defmethod [{ :keys [ docstring raw forms valid-call method-value verb ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" method-value \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( render-valid-call valid-call ) \"\\n\\n\" ( admonition { :content ( code-block raw 0 ) :type \"info\" :title ( str \"(\" ( code-inline verb ) \")\" ) :optional true }) \"\\n\" )) render-code-form :comment \u00b6 ( render-code-form { :keys [ raw ] :as m }) ( defmethod ) ( defmethod render-code-form :comment [{ :keys [ raw ] :as m }] ( str \"## Rich Comment\\n\\n\" ( code-block raw 0 ) \"\\n\\n\" )) render-form \u00b6 ( defmulti ) ( defmulti render-form :type ) render-form :default \u00b6 ( render-form { :keys [ docstring raw ]}) ( defmethod ) ( defmethod render-form :default [{ :keys [ docstring raw ]}] ( str docstring \"\\n\\n\" ( code-block raw ))) This is a comment for testing comments in forms => (+ 2 2) render-form :comment \u00b6 ( render-form { :keys [ docstring raw forms ] :as m }) ( defmethod ) ( defmethod render-form :comment [{ :keys [ docstring raw forms ] :as m }] ( if ( str/starts-with? raw \"=>\" ) ( str \"Result:\" ( code-block raw ) \"\\n\\n\" ) ( str raw \"\\n\\n\" ))) render-form :code \u00b6 rely on two level dispatch to catch all possible verbs and extend it, to keep it open the flat hierarchy is a closed system. ( render-form m ) ( defmethod ) ( defmethod render-form :code [ m ] ( render-code-form m )) function-forms \u00b6 Retrived function calling forms. Inspired by clojure.core/fn and clojure.core/multimethod definition. Returns The valid function calls are returned. Expects valid code without docstrings. ( function-forms name & sigs ) ( defn ) ( defn function-forms [ name & sigs ] ( let [ sigs ( if ( map? ( first sigs )) ( drop 1 sigs ) sigs ) sigs ( if ( vector? ( first sigs )) ( list sigs ) sigs )] ( mapv # ( seq ( into [ name ] ( first % ))) sigs ))) extended-raw->forms \u00b6 ( defmulti ) ( defmulti extended-raw->forms first ) ( defmethod extended-raw->forms :default [ _ ] {}) extended-raw->forms (quote defn) \u00b6 ( extended-raw->forms forms ) ( defmethod ) ( defmethod extended-raw->forms 'defn [ forms ] { :valid-call ( apply function-forms ( drop 1 forms ))}) extended-raw->forms (quote defmethod) \u00b6 ( extended-raw->forms forms ) ( defmethod ) ( defmethod extended-raw->forms 'defmethod [ forms ] { :valid-call ( apply function-forms ( second forms ) ( drop 3 forms )) :method-value ( nth forms 2 )}) evaluate-form* \u00b6 Brute force elementary parser on raw string to provide when for non valid forms. We use marginalia parser and sometimes the parse function does not return as valid raw form. In this case, an elementary custom algorithm is provided to still provide the information to the user. ( defn- ) ( defn- evaluate-form* [ raw { :keys [ docstring ] :as m }] ( let [ docstring ( str ( admonition { :content ( str \"The displayed code is not valid. \" \"This is due to Marginalia's parsing code.\" ) :type \"danger\" :title \"Parsing error\" :optional false }) \"\\n\\n\" docstring ) forms ( ->> ( str/split ( subs raw 1 ( dec ( dec ( count raw )))) # \" \" 3 ) ( map str/trim ))] ( assoc m :docstring docstring :forms forms ))) evaluate-form \u00b6 ( evaluate-form raw m ) ( defn ) ( defn evaluate-form [ raw m ] ( try ( binding [ clojure.tools.reader/*read-eval* false ] { :forms ( clojure.tools.reader/read-string raw )}) ( catch Exception _ ( println \"\\nParser mistake from marginalia, attempt to rescue with brute force.\" ) ( println ( str raw \"\\n\" )) ( evaluate-form* raw m )))) raw->forms \u00b6 ( raw->forms { :keys [ raw ] :as m }) ( defn ) ( defn ^ { :meta-data :true } raw->forms [{ :keys [ raw ] :as m }] ( let [{ :keys [ forms ] :as m } ( evaluate-form raw m ) verb ( first forms ) name ( second forms )] ( merge m { :forms forms :verb verb :var name } ( extended-raw->forms forms )))) comment here save-md \u00b6 Save markdown built from clojure source. ( save-md filename options ) ( defn ) ( defn save-md [ filename options ] ( let [ target ( :target options ( str ( second ( re-find # \"(.*)\\.(\\w+)$\" filename )) \".md\" ))] ( clojure.java.io/make-parents target ) ( when-not ( :append options ) ( spit target \"\" )) ( doseq [{ :keys [ type ] :as all } ( p/parse-file filename )] ( let [ all ( cond-> all ( and ( = type :code ) ( :raw all )) ( merge ( raw->forms all )) :always identity )] ( spit target ( render-form all ) :append true ))))) multidoc! \u00b6 Generate an output file for each of provided namespace. ( multidoc! docs files options ) ( defn ) ( defn multidoc! [ docs files options ] ( doseq [ filename files ] ( println filename ) ( let [ file-ns ( path-to-doc filename ) target-filename ( str docs \"/\" ( str/replace ( :ns file-ns ) # \"\\.\" \"/\" ) \".md\" )] ( save-md filename ( assoc options :target target-filename ))))) uberdoc! \u00b6 ( uberdoc! docs files options ) ( defn ) ( defn uberdoc! [ docs files options ] ( doseq [ filename files ] ( save-md filename ( assoc options :append true :target docs )))) Rich Comment \u00b6 ( comment ;; Rich comment ( keyword ( :verb ( raw->forms \"(rf/reg-sub ::hello (fn [m] 3))\" ))) ( raw->forms \"(defn hello {:pre (constantly true)} ([m] 3))\" ) ( p/parse \"(defn hello \\\"hello\\\" {:pre (constantly true)} ([m] 3))\" ) ( raw->forms \"(reg-sub ::hello (fn [m] 3))\" ) ( raw->forms \"(defmethod hello 3 [{:keys [a b]}] 3)\" ) ( function-forms ' ( def hello { :pre identity } [ m ] 3 )))","title":"materiala.markdown"},{"location":"materiala/markdown/#materialamarkdown","text":"Utilities for parsing code into markdown ( ns ) ( ns materiala.markdown ( :require [ clojure.java.io ] [ clojure.string :as str ] [ clojure.edn ] [ clojure.tools.reader ] [ marginalia.parser :as p ]))","title":"materiala.markdown"},{"location":"materiala/markdown/#drop-at","text":"Helper function to work with indices. Drop element from coll at indices idx . ( drop-at idx coll ) ( defn ) ( defn drop-at [ idx coll ] ( let [ n ( count coll ) idx ( sort ( if ( sequential? idx ) idx [ idx ]))] ( loop [ indices idx iteration 0 v coll ] ( if ( and ( seq indices ) ( < iteration n )) ( let [ i ( - ( first indices ) iteration ) v ( vec v )] ( recur ( rest indices ) ( inc iteration ) ( concat ( subvec v 0 i ) ( subvec v ( inc i ))))) ( vec v )))))","title":"drop-at"},{"location":"materiala/markdown/#path-to-doc","text":"( path-to-doc fn ) ( defn ) ( defn path-to-doc [ fn ] { :ns ( p/parse-ns ( java.io.File. fn )) :groups ( p/parse-file fn )})","title":"path-to-doc"},{"location":"materiala/markdown/#indent","text":"Indent string portion ( indent s indent-level ) ( defn ) ( defn indent [ s indent-level ] ( let [ indent-space ( str/join \"\" ( repeat indent-level \" \" ))] ( str/join \"\\n\" ( map # ( str indent-space % ) ( str/split s # \"\\n\" )))))","title":"indent"},{"location":"materiala/markdown/#code-block","text":"Create code block from given string s ( code-block s ) ( code-block s indent-level ) ( defn ) ( defn code-block ([ s ] ( code-block s 4 )) ([ s indent-level ] ( indent ( str \"```clojure\\n\" s \"\\n\" \"```\\n\\n\" ) indent-level )))","title":"code-block"},{"location":"materiala/markdown/#admonition","text":"Parsing error The displayed code is not valid. This is due to Marginalia's parsing code. ( defn ) ( defn admonition [{ :keys [ content type optional open title ] :or { optional false open false }}] ( str ( cond ( not optional ) \"!!! \" ( and optional open ) \"???+\" :else \"??? \" ) type \" \" ( when title ( str \" \\ title \" \\) ) \"\\n\\n\" ( indent content 4 )))","title":"admonition"},{"location":"materiala/markdown/#code-inline","text":"( code-inline s ) ( defn ) ( defn code-inline [ s ] ( str \"`\" s \"`\" ))","title":"code-inline"},{"location":"materiala/markdown/#render-valid-call","text":"( render-valid-call valid-call ) ( defn ) ( defn render-valid-call [ valid-call ] ( when valid-call ( -> ( str/join \"\\n\" ( map str valid-call )) ( str/replace # \",\" ) ( code-block 0 ))))","title":"render-valid-call"},{"location":"materiala/markdown/#render-def-form","text":"( render-def-form { :keys [ docstring raw forms level verb valid-call ] :or { level 2 }}) ( defn ) ( defn render-def-form [{ :keys [ docstring raw forms level verb valid-call ] :or { level 2 }}] ( str ( str/join ( repeat level \"#\" )) \" \" ( case verb 'ns ( second forms ) ( code-inline ( second forms ))) ;; keep the ear-muff variable to get md rendered \"\\n\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( render-valid-call valid-call ) \"\\n\\n\" ( admonition { :content ( code-block raw 0 ) :type \"tip\" :title ( str \"(\" ( code-inline verb ) \")\" ) :optional true }) \"\\n\\n\" ))","title":"render-def-form"},{"location":"materiala/markdown/#render-code-form","text":"( defmulti ) ( defmulti render-code-form ( fn [ m ] ( -> m :verb keyword )))","title":"render-code-form"},{"location":"materiala/markdown/#render-code-form-default","text":"( render-code-form { :keys [ docstring raw forms valid-call ] :as m }) ( defmethod ) ( defmethod render-code-form :default [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m ))","title":"render-code-form :default"},{"location":"materiala/markdown/#render-code-form-ns","text":"( render-code-form { :keys [ docstring raw forms valid-call ] :as m }) ( defmethod ) ( defmethod render-code-form :ns [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form ( assoc m :level 1 )))","title":"render-code-form :ns"},{"location":"materiala/markdown/#render-code-form-defmethod","text":"( render-code-form { :keys [ docstring raw forms valid-call method-value verb ] :as m }) ( defmethod ) ( defmethod render-code-form :defmethod [{ :keys [ docstring raw forms valid-call method-value verb ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" method-value \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( render-valid-call valid-call ) \"\\n\\n\" ( admonition { :content ( code-block raw 0 ) :type \"info\" :title ( str \"(\" ( code-inline verb ) \")\" ) :optional true }) \"\\n\" ))","title":"render-code-form :defmethod"},{"location":"materiala/markdown/#render-code-form-comment","text":"( render-code-form { :keys [ raw ] :as m }) ( defmethod ) ( defmethod render-code-form :comment [{ :keys [ raw ] :as m }] ( str \"## Rich Comment\\n\\n\" ( code-block raw 0 ) \"\\n\\n\" ))","title":"render-code-form :comment"},{"location":"materiala/markdown/#render-form","text":"( defmulti ) ( defmulti render-form :type )","title":"render-form"},{"location":"materiala/markdown/#render-form-default","text":"( render-form { :keys [ docstring raw ]}) ( defmethod ) ( defmethod render-form :default [{ :keys [ docstring raw ]}] ( str docstring \"\\n\\n\" ( code-block raw ))) This is a comment for testing comments in forms => (+ 2 2)","title":"render-form :default"},{"location":"materiala/markdown/#render-form-comment","text":"( render-form { :keys [ docstring raw forms ] :as m }) ( defmethod ) ( defmethod render-form :comment [{ :keys [ docstring raw forms ] :as m }] ( if ( str/starts-with? raw \"=>\" ) ( str \"Result:\" ( code-block raw ) \"\\n\\n\" ) ( str raw \"\\n\\n\" )))","title":"render-form :comment"},{"location":"materiala/markdown/#render-form-code","text":"rely on two level dispatch to catch all possible verbs and extend it, to keep it open the flat hierarchy is a closed system. ( render-form m ) ( defmethod ) ( defmethod render-form :code [ m ] ( render-code-form m ))","title":"render-form :code"},{"location":"materiala/markdown/#function-forms","text":"Retrived function calling forms. Inspired by clojure.core/fn and clojure.core/multimethod definition. Returns The valid function calls are returned. Expects valid code without docstrings. ( function-forms name & sigs ) ( defn ) ( defn function-forms [ name & sigs ] ( let [ sigs ( if ( map? ( first sigs )) ( drop 1 sigs ) sigs ) sigs ( if ( vector? ( first sigs )) ( list sigs ) sigs )] ( mapv # ( seq ( into [ name ] ( first % ))) sigs )))","title":"function-forms"},{"location":"materiala/markdown/#extended-raw-forms","text":"( defmulti ) ( defmulti extended-raw->forms first ) ( defmethod extended-raw->forms :default [ _ ] {})","title":"extended-raw-&gt;forms"},{"location":"materiala/markdown/#extended-raw-forms-quote-defn","text":"( extended-raw->forms forms ) ( defmethod ) ( defmethod extended-raw->forms 'defn [ forms ] { :valid-call ( apply function-forms ( drop 1 forms ))})","title":"extended-raw-&gt;forms (quote defn)"},{"location":"materiala/markdown/#extended-raw-forms-quote-defmethod","text":"( extended-raw->forms forms ) ( defmethod ) ( defmethod extended-raw->forms 'defmethod [ forms ] { :valid-call ( apply function-forms ( second forms ) ( drop 3 forms )) :method-value ( nth forms 2 )})","title":"extended-raw-&gt;forms (quote defmethod)"},{"location":"materiala/markdown/#evaluate-form","text":"Brute force elementary parser on raw string to provide when for non valid forms. We use marginalia parser and sometimes the parse function does not return as valid raw form. In this case, an elementary custom algorithm is provided to still provide the information to the user. ( defn- ) ( defn- evaluate-form* [ raw { :keys [ docstring ] :as m }] ( let [ docstring ( str ( admonition { :content ( str \"The displayed code is not valid. \" \"This is due to Marginalia's parsing code.\" ) :type \"danger\" :title \"Parsing error\" :optional false }) \"\\n\\n\" docstring ) forms ( ->> ( str/split ( subs raw 1 ( dec ( dec ( count raw )))) # \" \" 3 ) ( map str/trim ))] ( assoc m :docstring docstring :forms forms )))","title":"evaluate-form*"},{"location":"materiala/markdown/#evaluate-form_1","text":"( evaluate-form raw m ) ( defn ) ( defn evaluate-form [ raw m ] ( try ( binding [ clojure.tools.reader/*read-eval* false ] { :forms ( clojure.tools.reader/read-string raw )}) ( catch Exception _ ( println \"\\nParser mistake from marginalia, attempt to rescue with brute force.\" ) ( println ( str raw \"\\n\" )) ( evaluate-form* raw m ))))","title":"evaluate-form"},{"location":"materiala/markdown/#raw-forms","text":"( raw->forms { :keys [ raw ] :as m }) ( defn ) ( defn ^ { :meta-data :true } raw->forms [{ :keys [ raw ] :as m }] ( let [{ :keys [ forms ] :as m } ( evaluate-form raw m ) verb ( first forms ) name ( second forms )] ( merge m { :forms forms :verb verb :var name } ( extended-raw->forms forms )))) comment here","title":"raw-&gt;forms"},{"location":"materiala/markdown/#save-md","text":"Save markdown built from clojure source. ( save-md filename options ) ( defn ) ( defn save-md [ filename options ] ( let [ target ( :target options ( str ( second ( re-find # \"(.*)\\.(\\w+)$\" filename )) \".md\" ))] ( clojure.java.io/make-parents target ) ( when-not ( :append options ) ( spit target \"\" )) ( doseq [{ :keys [ type ] :as all } ( p/parse-file filename )] ( let [ all ( cond-> all ( and ( = type :code ) ( :raw all )) ( merge ( raw->forms all )) :always identity )] ( spit target ( render-form all ) :append true )))))","title":"save-md"},{"location":"materiala/markdown/#multidoc","text":"Generate an output file for each of provided namespace. ( multidoc! docs files options ) ( defn ) ( defn multidoc! [ docs files options ] ( doseq [ filename files ] ( println filename ) ( let [ file-ns ( path-to-doc filename ) target-filename ( str docs \"/\" ( str/replace ( :ns file-ns ) # \"\\.\" \"/\" ) \".md\" )] ( save-md filename ( assoc options :target target-filename )))))","title":"multidoc!"},{"location":"materiala/markdown/#uberdoc","text":"( uberdoc! docs files options ) ( defn ) ( defn uberdoc! [ docs files options ] ( doseq [ filename files ] ( save-md filename ( assoc options :append true :target docs ))))","title":"uberdoc!"},{"location":"materiala/markdown/#rich-comment","text":"( comment ;; Rich comment ( keyword ( :verb ( raw->forms \"(rf/reg-sub ::hello (fn [m] 3))\" ))) ( raw->forms \"(defn hello {:pre (constantly true)} ([m] 3))\" ) ( p/parse \"(defn hello \\\"hello\\\" {:pre (constantly true)} ([m] 3))\" ) ( raw->forms \"(reg-sub ::hello (fn [m] 3))\" ) ( raw->forms \"(defmethod hello 3 [{:keys [a b]}] 3)\" ) ( function-forms ' ( def hello { :pre identity } [ m ] 3 )))","title":"Rich Comment"},{"location":"materiala/extensions/core/","text":"materiala.extensions.core \u00b6 Collect extension to have simple import in core.clj ( ns ) ( ns materiala.extensions.core ( :require [ materiala.extensions.re-frame ]))","title":"materiala.extensions.core"},{"location":"materiala/extensions/core/#materialaextensionscore","text":"Collect extension to have simple import in core.clj ( ns ) ( ns materiala.extensions.core ( :require [ materiala.extensions.re-frame ]))","title":"materiala.extensions.core"},{"location":"materiala/extensions/re-frame-test/","text":"materiala.extensions.re-frame-test \u00b6 Example namespace for rendering custom macros ( ns ) ( ns materiala.extensions.re-frame-test ( :require [ re-frame.core :as rf :refer ( reg-event-fx reg-sub )] [ materiala.markdown :as mm ] [ materiala.extensions.re-frame ] [ clojure.test :as t :refer ( deftest are is )])) reg-event-fx : :user/initialize \u00b6 ( rf/reg-event-fx ::initialize ( fn [ cofx _ ] ( println \"Hello with namespace keywords!\" ) cofx )) reg-sub : :user/all \u00b6 ( rf/reg-sub ::all ;; not really good engineering ( fn [ db ] db )) reg-event-fx : :initialize \u00b6 ( reg-event-fx :initialize ( fn [ cofx _ ] ( println \"Hello without namespace!\" ) cofx )) reg-sub : :all \u00b6 ( reg-sub :all ;; not really good engineering ( fn [ db ] db )) reg-sub : :user/dispath-fn \u00b6 Dispatch-fn: println re-frame-simple-register \u00b6 ( deftest ) ( deftest re-frame-simple-register ( are [ raw markdown ] ( = markdown ( -> ( mm/raw->forms raw ) ( assoc :type :code :raw raw ) mm/render-form )) \"(reg-sub :all ;; not really good engineering (fn [db] db))\" \"## Event: `:all`\\n\\n```clojure\\n(reg-sub\\n:all ;; not really good engineering\\n(fn [db] db))\\n```\\n\\n\" \"(reg-sub ::all ;; not really good engineering dispatch-all-fn)\" \"## Event: `:materiala.extensions.re-frame/all`\\n\\nDispatch-fn: `dispatch-all-fn`\\n\\n\" ))","title":"materiala.extensions.re-frame-test"},{"location":"materiala/extensions/re-frame-test/#materialaextensionsre-frame-test","text":"Example namespace for rendering custom macros ( ns ) ( ns materiala.extensions.re-frame-test ( :require [ re-frame.core :as rf :refer ( reg-event-fx reg-sub )] [ materiala.markdown :as mm ] [ materiala.extensions.re-frame ] [ clojure.test :as t :refer ( deftest are is )]))","title":"materiala.extensions.re-frame-test"},{"location":"materiala/extensions/re-frame-test/#reg-event-fx-userinitialize","text":"( rf/reg-event-fx ::initialize ( fn [ cofx _ ] ( println \"Hello with namespace keywords!\" ) cofx ))","title":"reg-event-fx: :user/initialize"},{"location":"materiala/extensions/re-frame-test/#reg-sub-userall","text":"( rf/reg-sub ::all ;; not really good engineering ( fn [ db ] db ))","title":"reg-sub: :user/all"},{"location":"materiala/extensions/re-frame-test/#reg-event-fx-initialize","text":"( reg-event-fx :initialize ( fn [ cofx _ ] ( println \"Hello without namespace!\" ) cofx ))","title":"reg-event-fx: :initialize"},{"location":"materiala/extensions/re-frame-test/#reg-sub-all","text":"( reg-sub :all ;; not really good engineering ( fn [ db ] db ))","title":"reg-sub: :all"},{"location":"materiala/extensions/re-frame-test/#reg-sub-userdispath-fn","text":"Dispatch-fn: println","title":"reg-sub: :user/dispath-fn"},{"location":"materiala/extensions/re-frame-test/#re-frame-simple-register","text":"( deftest ) ( deftest re-frame-simple-register ( are [ raw markdown ] ( = markdown ( -> ( mm/raw->forms raw ) ( assoc :type :code :raw raw ) mm/render-form )) \"(reg-sub :all ;; not really good engineering (fn [db] db))\" \"## Event: `:all`\\n\\n```clojure\\n(reg-sub\\n:all ;; not really good engineering\\n(fn [db] db))\\n```\\n\\n\" \"(reg-sub ::all ;; not really good engineering dispatch-all-fn)\" \"## Event: `:materiala.extensions.re-frame/all`\\n\\nDispatch-fn: `dispatch-all-fn`\\n\\n\" ))","title":"re-frame-simple-register"},{"location":"materiala/extensions/re-frame/","text":"materiala.extensions.re-frame \u00b6 Example of extension not perfect parsing of re-frame forms ( ns ) ( ns materiala.extensions.re-frame ( :require [ materiala.markdown :as mm :refer ( render-code-form code-block code-inline )])) :rf/reg-event-fx \u00b6 ( derive ) ( derive :rf/reg-event-fx ::register ) ( derive :rf/reg-sub ::register ) render-code-form :user/register \u00b6 ( render-code-form { :keys [ raw forms ]}) ( defmethod ) ( defmethod render-code-form ::register [{ :keys [ raw forms ]}] ( str \"## \" ( code-inline ( name ( first forms ))) \": \" ( code-inline ( second forms )) \"\\n\\n\" ( if ( symbol? ( nth forms 2 )) ( str \"Dispatch-fn: \" ( code-inline ( nth forms 2 ))) ;; here we could have a better rendering by leveraing the code as data ;; by showing how it the event can be called ( code-block raw 0 )) \"\\n\\n\" )) render-code-form :reg-sub \u00b6 no shortcut here, have to do it ( render-code-form m ) ( defmethod ) ( defmethod render-code-form :reg-sub [ m ] ( render-code-form ( assoc m :verb ::register ))) render-code-form :reg-event-fx \u00b6 ( render-code-form m ) ( defmethod ) ( defmethod render-code-form :reg-event-fx [ m ] ( render-code-form ( assoc m :verb ::register ))) Rich Comment \u00b6 ( comment ( let [ raw \"(reg-sub ::all ;; not really good engineering dispatch-all-fn)\" ] ( -> ( mm/raw->forms raw ) ( assoc :type :code :raw raw ) mm/render-form )))","title":"materiala.extensions.re-frame"},{"location":"materiala/extensions/re-frame/#materialaextensionsre-frame","text":"Example of extension not perfect parsing of re-frame forms ( ns ) ( ns materiala.extensions.re-frame ( :require [ materiala.markdown :as mm :refer ( render-code-form code-block code-inline )]))","title":"materiala.extensions.re-frame"},{"location":"materiala/extensions/re-frame/#rfreg-event-fx","text":"( derive ) ( derive :rf/reg-event-fx ::register ) ( derive :rf/reg-sub ::register )","title":":rf/reg-event-fx"},{"location":"materiala/extensions/re-frame/#render-code-form-userregister","text":"( render-code-form { :keys [ raw forms ]}) ( defmethod ) ( defmethod render-code-form ::register [{ :keys [ raw forms ]}] ( str \"## \" ( code-inline ( name ( first forms ))) \": \" ( code-inline ( second forms )) \"\\n\\n\" ( if ( symbol? ( nth forms 2 )) ( str \"Dispatch-fn: \" ( code-inline ( nth forms 2 ))) ;; here we could have a better rendering by leveraing the code as data ;; by showing how it the event can be called ( code-block raw 0 )) \"\\n\\n\" ))","title":"render-code-form :user/register"},{"location":"materiala/extensions/re-frame/#render-code-form-reg-sub","text":"no shortcut here, have to do it ( render-code-form m ) ( defmethod ) ( defmethod render-code-form :reg-sub [ m ] ( render-code-form ( assoc m :verb ::register )))","title":"render-code-form :reg-sub"},{"location":"materiala/extensions/re-frame/#render-code-form-reg-event-fx","text":"( render-code-form m ) ( defmethod ) ( defmethod render-code-form :reg-event-fx [ m ] ( render-code-form ( assoc m :verb ::register )))","title":"render-code-form :reg-event-fx"},{"location":"materiala/extensions/re-frame/#rich-comment","text":"( comment ( let [ raw \"(reg-sub ::all ;; not really good engineering dispatch-all-fn)\" ] ( -> ( mm/raw->forms raw ) ( assoc :type :code :raw raw ) mm/render-form )))","title":"Rich Comment"}]}
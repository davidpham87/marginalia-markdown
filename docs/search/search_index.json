{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Materiala \u00b6 Experience to leverage marginalia parser and mkdocs-material to create documentation. Example: https://davidpham87.github.io/materiala/ Rationale \u00b6 I really liked calva.io website for documentation [I still use emacs+cider] , and I saw it was based mkdocs-material . Since then, I wanted to use it for my own documentation. We already have marginalia, codox and cljdoc, so this library does not add a lot, but I still wanted to have a nice UI for personal project and as a nice project. My only experience before with auto-documentation/literal programming was org-file, marginalia and codox. Technical Solution \u00b6 Marginalia API was easier to leverage (and marginalia had a nice website), although codox (because neanderthal and the uncomplicate ecosystem) was considered for usage and extension by coding a specific writer. Quick start \u00b6 pip3 install mkdocs-material # parse your src fodler and generate the files into ./doc clj -m materiala.core -d doc src mkdocs serve # dev mkdocs build # release Example mkdocs.yml \u00b6 Here is an example of mkdocs.yml file that could be used for a github repository. site_name : Materiala repo_url : https://github.com/davidpham87/materiala repo_name : github docs_dir : doc site_dir : docs # github like this one for displaying your website theme : name : material markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true - pymdownx.arithmatex - pymdownx.superfences - pymdownx.inlinehilite - pymdownx.details extra_javascript : - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML plugins : - search # necessary for search to work - awesome-pages Development \u00b6 Run a repl (add your cider deps as well) clojure -Adev Run the test (todo: create some specs and generate with test.check ) clojure -Atest License \u00b6 Copyright (C) 2020 David Pham Distributed under the Eclipse Public License, the same as Clojure.","title":"Materiala"},{"location":"#materiala","text":"Experience to leverage marginalia parser and mkdocs-material to create documentation. Example: https://davidpham87.github.io/materiala/","title":"Materiala"},{"location":"#rationale","text":"I really liked calva.io website for documentation [I still use emacs+cider] , and I saw it was based mkdocs-material . Since then, I wanted to use it for my own documentation. We already have marginalia, codox and cljdoc, so this library does not add a lot, but I still wanted to have a nice UI for personal project and as a nice project. My only experience before with auto-documentation/literal programming was org-file, marginalia and codox.","title":"Rationale"},{"location":"#technical-solution","text":"Marginalia API was easier to leverage (and marginalia had a nice website), although codox (because neanderthal and the uncomplicate ecosystem) was considered for usage and extension by coding a specific writer.","title":"Technical Solution"},{"location":"#quick-start","text":"pip3 install mkdocs-material # parse your src fodler and generate the files into ./doc clj -m materiala.core -d doc src mkdocs serve # dev mkdocs build # release","title":"Quick start"},{"location":"#example-mkdocsyml","text":"Here is an example of mkdocs.yml file that could be used for a github repository. site_name : Materiala repo_url : https://github.com/davidpham87/materiala repo_name : github docs_dir : doc site_dir : docs # github like this one for displaying your website theme : name : material markdown_extensions : - admonition - codehilite : guess_lang : false - toc : permalink : true - pymdownx.arithmatex - pymdownx.superfences - pymdownx.inlinehilite - pymdownx.details extra_javascript : - https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML plugins : - search # necessary for search to work - awesome-pages","title":"Example mkdocs.yml"},{"location":"#development","text":"Run a repl (add your cider deps as well) clojure -Adev Run the test (todo: create some specs and generate with test.check ) clojure -Atest","title":"Development"},{"location":"#license","text":"Copyright (C) 2020 David Pham Distributed under the Eclipse Public License, the same as Clojure.","title":"License"},{"location":"materiala/core/","text":"materiala.core \u00b6 Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\pi} = -1 $$ (ns) ( ns materiala.core \"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\\\pi} = -1 $$ \" ( :require [ clojure.java.io :as io ] [ clojure.tools.cli :refer ( parse-opts )] [ marginalia.core :as mc ] [ materiala.markdown ])) docs \u00b6 (def) ( def ^ { :dynamic true } *docs* \"./docs\" ) cli-opts \u00b6 (def) ( def cli-opts [[ \"-d\" \"--dir DIR\" \"Directory into which the documentation will be written\" :default \"./docs\" ] [ \"-f\" \"--file FILE\" \"File into which the documentation will be written\" ] [ \"-n\" \"--name NAME\" \"Project name - if not given will be taken from project.clj\" ] [ \"-v\" \"--version VERSION\" \"Project version - if not given will be taken from project.clj\" ] [ \"-D\" \"--desc DESC\" \"Project description - if not given will be taken from project.clj\" ] [ \"-a\" \"--deps DEPS\" \"Project dependencies in the form <group1>:<artifact1>:<version1>;<group2>... If not given will be taken from project.clj\" ] [ \"-m\" \"--multi\" \"Generate each namespace documentation as a separate file\" :default true ] [ \"-l\" \"--leiningen\" \"Generate the documentation for a Leiningen project file.\" ] [ \"-e\" \"--exclude EXCLUDE\" \"Exclude source file(s) from the document generation process <file1>;<file2>... If not given will be taken from project.clj\" ] [ \"-h\" \"--help\" \"Show this help\" ]]) run-materiala \u00b6 Default generation: given a collection of filepaths in a project, find the .clj files at these paths and, if Clojure source files are found: Print out a message to std out letting a user know which files are to be processed; Create the docs directory inside the project folder if it doesn't already exist; Call the uberdoc! function to generate the output file at its default location, using the found source files and a project file expected to be in its default location. If no source files are found, complain with a usage message. ( run-materiala & args ) (defn) ( defn run-materiala [ & args ] ( let [ user-parsed-options ( parse-opts args cli-opts ) { :keys [ dir file name version desc deps multi leiningen exclude arguments help ]} ( :options user-parsed-options ) files arguments sources ( distinct ( mc/format-sources ( seq files ))) sources ( if leiningen ( cons leiningen sources ) sources )] ( when help ( println ( :summary user-parsed-options ))) ( if ( and sources ( not help )) ( binding [ *docs* dir ] ( let [ project-clj ( when ( .exists ( io/file \"project.clj\" )) ( mc/parse-project-file )) choose # ( or %1 %2 ) marg-opts ( merge-with choose { :exclude ( when exclude ( .split exclude \";\" )) :leiningen leiningen } ( :marginalia project-clj )) opts ( merge-with choose { :name name :version version :description desc :dependencies ( mc/split-deps deps ) :multi multi :marginalia marg-opts } project-clj ) sources ( ->> sources ( filter # ( not ( mc/source-excluded? % opts ))) ( into []))] ( println \"Generating Marginalia documentation for the following source files:\" ) ( doseq [ s sources ] ( println \" \" s )) ( println ) ( mc/ensure-directory! *docs* ) ( if multi ( materiala.markdown/multidoc! *docs* sources opts ) ( materiala.markdown/uberdoc! ( str *docs* \"/\" file ) sources opts )) ( println \"Done generating your documentation in\" *docs* ) ( println \"\" ))) ( when-not help ( println \"Wrong number of arguments passed to Marginalia.\" ) ( println ( :summary user-parsed-options )))))) -main \u00b6 ( -main & args ) (defn) ( defn -main [ & args ] ( apply run-materiala args ))","title":"materiala.core"},{"location":"materiala/core/#materialacore","text":"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\pi} = -1 $$ (ns) ( ns materiala.core \"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\\\pi} = -1 $$ \" ( :require [ clojure.java.io :as io ] [ clojure.tools.cli :refer ( parse-opts )] [ marginalia.core :as mc ] [ materiala.markdown ]))","title":"materiala.core"},{"location":"materiala/core/#docs","text":"(def) ( def ^ { :dynamic true } *docs* \"./docs\" )","title":"docs"},{"location":"materiala/core/#cli-opts","text":"(def) ( def cli-opts [[ \"-d\" \"--dir DIR\" \"Directory into which the documentation will be written\" :default \"./docs\" ] [ \"-f\" \"--file FILE\" \"File into which the documentation will be written\" ] [ \"-n\" \"--name NAME\" \"Project name - if not given will be taken from project.clj\" ] [ \"-v\" \"--version VERSION\" \"Project version - if not given will be taken from project.clj\" ] [ \"-D\" \"--desc DESC\" \"Project description - if not given will be taken from project.clj\" ] [ \"-a\" \"--deps DEPS\" \"Project dependencies in the form <group1>:<artifact1>:<version1>;<group2>... If not given will be taken from project.clj\" ] [ \"-m\" \"--multi\" \"Generate each namespace documentation as a separate file\" :default true ] [ \"-l\" \"--leiningen\" \"Generate the documentation for a Leiningen project file.\" ] [ \"-e\" \"--exclude EXCLUDE\" \"Exclude source file(s) from the document generation process <file1>;<file2>... If not given will be taken from project.clj\" ] [ \"-h\" \"--help\" \"Show this help\" ]])","title":"cli-opts"},{"location":"materiala/core/#run-materiala","text":"Default generation: given a collection of filepaths in a project, find the .clj files at these paths and, if Clojure source files are found: Print out a message to std out letting a user know which files are to be processed; Create the docs directory inside the project folder if it doesn't already exist; Call the uberdoc! function to generate the output file at its default location, using the found source files and a project file expected to be in its default location. If no source files are found, complain with a usage message. ( run-materiala & args ) (defn) ( defn run-materiala [ & args ] ( let [ user-parsed-options ( parse-opts args cli-opts ) { :keys [ dir file name version desc deps multi leiningen exclude arguments help ]} ( :options user-parsed-options ) files arguments sources ( distinct ( mc/format-sources ( seq files ))) sources ( if leiningen ( cons leiningen sources ) sources )] ( when help ( println ( :summary user-parsed-options ))) ( if ( and sources ( not help )) ( binding [ *docs* dir ] ( let [ project-clj ( when ( .exists ( io/file \"project.clj\" )) ( mc/parse-project-file )) choose # ( or %1 %2 ) marg-opts ( merge-with choose { :exclude ( when exclude ( .split exclude \";\" )) :leiningen leiningen } ( :marginalia project-clj )) opts ( merge-with choose { :name name :version version :description desc :dependencies ( mc/split-deps deps ) :multi multi :marginalia marg-opts } project-clj ) sources ( ->> sources ( filter # ( not ( mc/source-excluded? % opts ))) ( into []))] ( println \"Generating Marginalia documentation for the following source files:\" ) ( doseq [ s sources ] ( println \" \" s )) ( println ) ( mc/ensure-directory! *docs* ) ( if multi ( materiala.markdown/multidoc! *docs* sources opts ) ( materiala.markdown/uberdoc! ( str *docs* \"/\" file ) sources opts )) ( println \"Done generating your documentation in\" *docs* ) ( println \"\" ))) ( when-not help ( println \"Wrong number of arguments passed to Marginalia.\" ) ( println ( :summary user-parsed-options ))))))","title":"run-materiala"},{"location":"materiala/core/#-main","text":"( -main & args ) (defn) ( defn -main [ & args ] ( apply run-materiala args ))","title":"-main"},{"location":"materiala/markdown/","text":"materiala.markdown \u00b6 Utilities for parsing code into markdown (ns) ( ns materiala.markdown ( :require [ clojure.java.io ] [ clojure.string :as str ] [ clojure.edn ] [ clojure.tools.reader ] [ marginalia.parser :as p ])) path-to-doc \u00b6 ( path-to-doc fn ) (defn) ( defn path-to-doc [ fn ] { :ns ( p/parse-ns ( java.io.File. fn )) :groups ( p/parse-file fn )}) indent \u00b6 Indent string portion ( indent s indent-level ) (defn) ( defn indent [ s indent-level ] ( let [ indent-space ( str/join \"\" ( repeat indent-level \" \" ))] ( str/join \"\\n\" ( map # ( str indent-space % ) ( str/split s # \"\\n\" ))))) code-block \u00b6 Create code block from given string s (defn-) ( defn- code-block ([ s ] ( code-block s 4 )) ([ s indent-level ] ( indent ( str \"```clojure\\n\" s \"\\n\" \"```\\n\\n\" ) indent-level ))) render-def-form \u00b6 ( render-def-form { :keys [ docstring raw forms level verb valid-call ] , :or { level 2 }}) (defn) ( defn render-def-form [{ :keys [ docstring raw forms level verb valid-call ] :or { level 2 }}] ( str ( str/join ( repeat level \"#\" )) \" \" ( second forms ) \"\\n\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( when valid-call ( code-block ( str/join \"\\n\" ( map str valid-call )) 0 )) \"\\n\\n\" \"??? tip \\\"(\" verb \")\\\"\\n\" ( code-block raw ) \"\\n\" )) render-form \u00b6 (defmulti) ( defmulti render-form ( fn [{ :keys [ type verb ]}] ( case type :comment [ :comment ] :code [ :code verb ] :default ))) render-form :default \u00b6 ( render-form { :keys [ docstring raw ]}) (defmethod) ( defmethod render-form :default [{ :keys [ docstring raw ]}] ( str docstring \"\\n\\n\" ( code-block raw ))) render-form [:code (quote ns)] \u00b6 ( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'ns ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form ( assoc m :level 1 ))) render-form [:code (quote def)] \u00b6 ( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'def ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m )) render-form [:code (quote defn)] \u00b6 ( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defn ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m )) render-form [:code (quote defn-)] \u00b6 ( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defn- ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m )) render-form [:code (quote defmacro)] \u00b6 ( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defmacro ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m )) render-form [:code (quote defmulti)] \u00b6 ( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defmulti ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m )) render-form [:code (quote defmethod)] \u00b6 ( render-form { :keys [ docstring raw forms verb method-value valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defmethod ] [{ :keys [ docstring raw forms verb method-value valid-call ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" method-value \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( when valid-call ( code-block ( str/join \"\\n\" ( map str valid-call )) 0 )) \"\\n\\n\" \"??? info \\\"(\" verb \")\\\"\\n\" ( code-block raw 4 ) \"\\n\" )) render-form [:comment] \u00b6 ( render-form { :keys [ docstring raw forms ] , :as m }) (defmethod) ( defmethod render-form [ :comment ] [{ :keys [ docstring raw forms ] :as m }] ( if ( str/starts-with? raw \"=>\" ) ( str \"Result:\" ( code-block raw ) \"\\n\\n\" ) ( str raw \"\\n\\n\" ))) This is a comment for testing comments in forms => (+ 2 2) function-forms \u00b6 Retrived function calling forms. Inspired by clojure.core/fn and clojure.core/multimethod definition. Returns The valid function calls are returned. Expects valid code without docstrings. (defn-) ( defn- function-forms [ name & sigs ] ( let [ sigs ( if ( vector? ( first sigs )) ( list sigs ) sigs )] ( mapv # ( seq ( into [ name ] ( first % ))) sigs ))) raw->forms \u00b6 ( raw->forms raw ) (defn) ( defn ^ { :meta-data :true } raw->forms [ raw ] ( binding [ clojure.tools.reader/*read-eval* false ] ( let [ forms ( clojure.tools.reader/read-string raw ) multimethod? ( = ( first forms ) 'defmethod ) verb ( first forms ) name ( second forms )] { :forms forms :verb verb :var name :valid-call ( condp = verb 'defn ( apply function-forms ( drop 1 forms )) 'defmethod ( apply function-forms ( second forms ) ( drop 3 forms )) nil ) :method-value ( when multimethod? ( nth forms 2 ))}))) comment here save-md \u00b6 Save markdown built from clojure source. ( save-md filename options ) (defn) ( defn save-md [ filename options ] ( let [ target ( :target options ( str ( second ( re-find # \"(.*)\\.(\\w+)$\" filename )) \".md\" ))] ( clojure.java.io/make-parents target ) ( when-not ( :append options ) ( spit target \"\" )) ( doseq [{ :keys [ raw type ] :as all } ( p/parse-file filename )] ( let [ all ( cond-> all ( and ( = type :code ) ( :raw all )) ( merge ( raw->forms raw )) :always identity )] ( spit target ( render-form all ) :append true ))))) multidoc! \u00b6 Generate an output file for each of provided namespace. ( multidoc! docs files options ) (defn) ( defn multidoc! [ docs files options ] ( doseq [ filename files ] ( println filename ) ( let [ file-ns ( path-to-doc filename ) target-filename ( str docs \"/\" ( str/replace ( :ns file-ns ) # \"\\.\" \"/\" ) \".md\" )] ( save-md filename ( assoc options :target target-filename ))))) uberdoc! \u00b6 ( uberdoc! docs files options ) (defn) ( defn uberdoc! [ docs files options ] ( doseq [ filename files ] ( save-md filename ( assoc options :append true :target docs )))) ( comment ( function-forms 'hello ' ([ x y ] 3 ) ' ([ x ] 3 )) ( raw->forms ' ( defn hello ([ x y ] 3 ) ([ x ] 3 ))) ( raw->forms \"(defn hello [x] 3)\" ) ' { :forms ( defn hello [ x ] 3 ) , :verb defn , :var hello , :valid-call [( hello x )] , :method-value nil } ( raw->forms \"(defn hello ([x] 3) ([x y] 3))\" ) ' { :forms ( defn hello ([ x ] 3 ) ([ x y ] 3 )) , :verb defn , :var hello , :valid-call [( hello x ) ( hello x y )] , :method-value nil } ( raw->forms \"(defmethod hello 3 [{:keys [a b]}] 3)\" ) ' { :forms ( defmethod hello 3 [{ :keys [ a b ]}] 3 ) , :verb defmethod , :var hello , :valid-call [( hello { :keys [ a b ]})] , :method-value 3 } ( raw->forms \"(def hello 3)\" ) ' { :forms ( def hello 3 ) , :verb def , :var hello , :valid-call nil , :method-value nil })","title":"materiala.markdown"},{"location":"materiala/markdown/#materialamarkdown","text":"Utilities for parsing code into markdown (ns) ( ns materiala.markdown ( :require [ clojure.java.io ] [ clojure.string :as str ] [ clojure.edn ] [ clojure.tools.reader ] [ marginalia.parser :as p ]))","title":"materiala.markdown"},{"location":"materiala/markdown/#path-to-doc","text":"( path-to-doc fn ) (defn) ( defn path-to-doc [ fn ] { :ns ( p/parse-ns ( java.io.File. fn )) :groups ( p/parse-file fn )})","title":"path-to-doc"},{"location":"materiala/markdown/#indent","text":"Indent string portion ( indent s indent-level ) (defn) ( defn indent [ s indent-level ] ( let [ indent-space ( str/join \"\" ( repeat indent-level \" \" ))] ( str/join \"\\n\" ( map # ( str indent-space % ) ( str/split s # \"\\n\" )))))","title":"indent"},{"location":"materiala/markdown/#code-block","text":"Create code block from given string s (defn-) ( defn- code-block ([ s ] ( code-block s 4 )) ([ s indent-level ] ( indent ( str \"```clojure\\n\" s \"\\n\" \"```\\n\\n\" ) indent-level )))","title":"code-block"},{"location":"materiala/markdown/#render-def-form","text":"( render-def-form { :keys [ docstring raw forms level verb valid-call ] , :or { level 2 }}) (defn) ( defn render-def-form [{ :keys [ docstring raw forms level verb valid-call ] :or { level 2 }}] ( str ( str/join ( repeat level \"#\" )) \" \" ( second forms ) \"\\n\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( when valid-call ( code-block ( str/join \"\\n\" ( map str valid-call )) 0 )) \"\\n\\n\" \"??? tip \\\"(\" verb \")\\\"\\n\" ( code-block raw ) \"\\n\" ))","title":"render-def-form"},{"location":"materiala/markdown/#render-form","text":"(defmulti) ( defmulti render-form ( fn [{ :keys [ type verb ]}] ( case type :comment [ :comment ] :code [ :code verb ] :default )))","title":"render-form"},{"location":"materiala/markdown/#render-form-default","text":"( render-form { :keys [ docstring raw ]}) (defmethod) ( defmethod render-form :default [{ :keys [ docstring raw ]}] ( str docstring \"\\n\\n\" ( code-block raw )))","title":"render-form :default"},{"location":"materiala/markdown/#render-form-code-quote-ns","text":"( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'ns ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form ( assoc m :level 1 )))","title":"render-form [:code (quote ns)]"},{"location":"materiala/markdown/#render-form-code-quote-def","text":"( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'def ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m ))","title":"render-form [:code (quote def)]"},{"location":"materiala/markdown/#render-form-code-quote-defn","text":"( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defn ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m ))","title":"render-form [:code (quote defn)]"},{"location":"materiala/markdown/#render-form-code-quote-defn-","text":"( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defn- ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m ))","title":"render-form [:code (quote defn-)]"},{"location":"materiala/markdown/#render-form-code-quote-defmacro","text":"( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defmacro ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m ))","title":"render-form [:code (quote defmacro)]"},{"location":"materiala/markdown/#render-form-code-quote-defmulti","text":"( render-form { :keys [ docstring raw forms valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defmulti ] [{ :keys [ docstring raw forms valid-call ] :as m }] ( render-def-form m ))","title":"render-form [:code (quote defmulti)]"},{"location":"materiala/markdown/#render-form-code-quote-defmethod","text":"( render-form { :keys [ docstring raw forms verb method-value valid-call ] , :as m }) (defmethod) ( defmethod render-form [ :code 'defmethod ] [{ :keys [ docstring raw forms verb method-value valid-call ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" method-value \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) ( when valid-call ( code-block ( str/join \"\\n\" ( map str valid-call )) 0 )) \"\\n\\n\" \"??? info \\\"(\" verb \")\\\"\\n\" ( code-block raw 4 ) \"\\n\" ))","title":"render-form [:code (quote defmethod)]"},{"location":"materiala/markdown/#render-form-comment","text":"( render-form { :keys [ docstring raw forms ] , :as m }) (defmethod) ( defmethod render-form [ :comment ] [{ :keys [ docstring raw forms ] :as m }] ( if ( str/starts-with? raw \"=>\" ) ( str \"Result:\" ( code-block raw ) \"\\n\\n\" ) ( str raw \"\\n\\n\" ))) This is a comment for testing comments in forms => (+ 2 2)","title":"render-form [:comment]"},{"location":"materiala/markdown/#function-forms","text":"Retrived function calling forms. Inspired by clojure.core/fn and clojure.core/multimethod definition. Returns The valid function calls are returned. Expects valid code without docstrings. (defn-) ( defn- function-forms [ name & sigs ] ( let [ sigs ( if ( vector? ( first sigs )) ( list sigs ) sigs )] ( mapv # ( seq ( into [ name ] ( first % ))) sigs )))","title":"function-forms"},{"location":"materiala/markdown/#raw-forms","text":"( raw->forms raw ) (defn) ( defn ^ { :meta-data :true } raw->forms [ raw ] ( binding [ clojure.tools.reader/*read-eval* false ] ( let [ forms ( clojure.tools.reader/read-string raw ) multimethod? ( = ( first forms ) 'defmethod ) verb ( first forms ) name ( second forms )] { :forms forms :verb verb :var name :valid-call ( condp = verb 'defn ( apply function-forms ( drop 1 forms )) 'defmethod ( apply function-forms ( second forms ) ( drop 3 forms )) nil ) :method-value ( when multimethod? ( nth forms 2 ))}))) comment here","title":"raw-&gt;forms"},{"location":"materiala/markdown/#save-md","text":"Save markdown built from clojure source. ( save-md filename options ) (defn) ( defn save-md [ filename options ] ( let [ target ( :target options ( str ( second ( re-find # \"(.*)\\.(\\w+)$\" filename )) \".md\" ))] ( clojure.java.io/make-parents target ) ( when-not ( :append options ) ( spit target \"\" )) ( doseq [{ :keys [ raw type ] :as all } ( p/parse-file filename )] ( let [ all ( cond-> all ( and ( = type :code ) ( :raw all )) ( merge ( raw->forms raw )) :always identity )] ( spit target ( render-form all ) :append true )))))","title":"save-md"},{"location":"materiala/markdown/#multidoc","text":"Generate an output file for each of provided namespace. ( multidoc! docs files options ) (defn) ( defn multidoc! [ docs files options ] ( doseq [ filename files ] ( println filename ) ( let [ file-ns ( path-to-doc filename ) target-filename ( str docs \"/\" ( str/replace ( :ns file-ns ) # \"\\.\" \"/\" ) \".md\" )] ( save-md filename ( assoc options :target target-filename )))))","title":"multidoc!"},{"location":"materiala/markdown/#uberdoc","text":"( uberdoc! docs files options ) (defn) ( defn uberdoc! [ docs files options ] ( doseq [ filename files ] ( save-md filename ( assoc options :append true :target docs )))) ( comment ( function-forms 'hello ' ([ x y ] 3 ) ' ([ x ] 3 )) ( raw->forms ' ( defn hello ([ x y ] 3 ) ([ x ] 3 ))) ( raw->forms \"(defn hello [x] 3)\" ) ' { :forms ( defn hello [ x ] 3 ) , :verb defn , :var hello , :valid-call [( hello x )] , :method-value nil } ( raw->forms \"(defn hello ([x] 3) ([x y] 3))\" ) ' { :forms ( defn hello ([ x ] 3 ) ([ x y ] 3 )) , :verb defn , :var hello , :valid-call [( hello x ) ( hello x y )] , :method-value nil } ( raw->forms \"(defmethod hello 3 [{:keys [a b]}] 3)\" ) ' { :forms ( defmethod hello 3 [{ :keys [ a b ]}] 3 ) , :verb defmethod , :var hello , :valid-call [( hello { :keys [ a b ]})] , :method-value 3 } ( raw->forms \"(def hello 3)\" ) ' { :forms ( def hello 3 ) , :verb def , :var hello , :valid-call nil , :method-value nil })","title":"uberdoc!"}]}
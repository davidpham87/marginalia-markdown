{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Marginalia Markdown \u00b6 Experience to leverage marginalia parser and mkdocs-material to create documentation. Quick start \u00b6 pip3 install mkdocs-material # parse your src fodler and generate the files into ./docs find src -type \"f\" -name \"*.clj*\" | xargs clj -m marginalia-md.core mkdocs serve # dev mkdocs build # release License \u00b6 Copyright (C) 2020 David Pham Distributed under the Eclipse Public License, the same as Clojure.","title":"Marginalia Markdown"},{"location":"#marginalia-markdown","text":"Experience to leverage marginalia parser and mkdocs-material to create documentation.","title":"Marginalia Markdown"},{"location":"#quick-start","text":"pip3 install mkdocs-material # parse your src fodler and generate the files into ./docs find src -type \"f\" -name \"*.clj*\" | xargs clj -m marginalia-md.core mkdocs serve # dev mkdocs build # release","title":"Quick start"},{"location":"#license","text":"Copyright (C) 2020 David Pham Distributed under the Eclipse Public License, the same as Clojure.","title":"License"},{"location":"marginalia-md/core/","text":"marginalia-md.core \u00b6 Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\pi} = -1 $$ (ns) ( ns marginalia-md.core \"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\\\pi} = -1 $$ \" ( :require [ clojure.java.io :as io ] [ clojure.tools.cli :refer ( parse-opts )] [ marginalia.core :as mc ] [ marginalia-md.markdown ])) docs \u00b6 (def) ( def ^ { :dynamic true } *docs* \"./docs\" ) cli-opts \u00b6 (def) ( def cli-opts [[ \"-d\" \"--dir DIR\" \"Directory into which the documentation will be written\" :default \"./docs\" ] [ \"-f\" \"--file FILE\" \"File into which the documentation will be written\" ] [ \"-n\" \"--name NAME\" \"Project name - if not given will be taken from project.clj\" ] [ \"-v\" \"--version VERSION\" \"Project version - if not given will be taken from project.clj\" ] [ \"-D\" \"--desc DESC\" \"Project description - if not given will be taken from project.clj\" ] [ \"-a\" \"--deps DEPS\" \"Project dependencies in the form <group1>:<artifact1>:<version1>;<group2>... If not given will be taken from project.clj\" ] [ \"-m\" \"--multi\" \"Generate each namespace documentation as a separate file\" :default true ] [ \"-l\" \"--leiningen\" \"Generate the documentation for a Leiningen project file.\" ] [ \"-e\" \"--exclude EXCLUDE\" \"Exclude source file(s) from the document generation process <file1>;<file2>... If not given will be taken from project.clj\" ] [ \"-h\" \"--help\" \"Show this help\" ]]) run-marginalia-md \u00b6 Default generation: given a collection of filepaths in a project, find the .clj files at these paths and, if Clojure source files are found: Print out a message to std out letting a user know which files are to be processed; Create the docs directory inside the project folder if it doesn't already exist; Call the uberdoc! function to generate the output file at its default location, using the found source files and a project file expected to be in its default location. If no source files are found, complain with a usage message. (defn) ( defn run-marginalia-md [ & args ] ( let [ user-parsed-options ( parse-opts args cli-opts ) { :keys [ dir file name version desc deps multi leiningen exclude arguments help ]} ( :options user-parsed-options ) files arguments sources ( distinct ( mc/format-sources ( seq files ))) sources ( if leiningen ( cons leiningen sources ) sources )] ( when help ( println ( :summary user-parsed-options ))) ( if ( and sources ( not help )) ( binding [ *docs* dir ] ( let [ project-clj ( when ( .exists ( io/file \"project.clj\" )) ( mc/parse-project-file )) choose # ( or %1 %2 ) marg-opts ( merge-with choose { :exclude ( when exclude ( .split exclude \";\" )) :leiningen leiningen } ( :marginalia project-clj )) opts ( merge-with choose { :name name :version version :description desc :dependencies ( mc/split-deps deps ) :multi multi :marginalia marg-opts } project-clj ) sources ( ->> sources ( filter # ( not ( mc/source-excluded? % opts ))) ( into []))] ( println \"Generating Marginalia documentation for the following source files:\" ) ( doseq [ s sources ] ( println \" \" s )) ( println ) ( mc/ensure-directory! *docs* ) ( if multi ( marginalia-md.markdown/multidoc! *docs* sources opts ) ( marginalia-md.markdown/uberdoc! ( str *docs* \"/\" file ) sources opts )) ( println \"Done generating your documentation in\" *docs* ) ( println \"\" ))) ( when-not help ( println \"Wrong number of arguments passed to Marginalia.\" ) ( println ( :summary user-parsed-options )))))) -main \u00b6 (defn) ( defn -main [ & args ] ( apply run-marginalia-md args ))","title":"marginalia-md.core"},{"location":"marginalia-md/core/#marginalia-mdcore","text":"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\pi} = -1 $$ (ns) ( ns marginalia-md.core \"Simple markdown conversion with some cool features, such as math rendering $$ e^{i\\\\pi} = -1 $$ \" ( :require [ clojure.java.io :as io ] [ clojure.tools.cli :refer ( parse-opts )] [ marginalia.core :as mc ] [ marginalia-md.markdown ]))","title":"marginalia-md.core"},{"location":"marginalia-md/core/#docs","text":"(def) ( def ^ { :dynamic true } *docs* \"./docs\" )","title":"docs"},{"location":"marginalia-md/core/#cli-opts","text":"(def) ( def cli-opts [[ \"-d\" \"--dir DIR\" \"Directory into which the documentation will be written\" :default \"./docs\" ] [ \"-f\" \"--file FILE\" \"File into which the documentation will be written\" ] [ \"-n\" \"--name NAME\" \"Project name - if not given will be taken from project.clj\" ] [ \"-v\" \"--version VERSION\" \"Project version - if not given will be taken from project.clj\" ] [ \"-D\" \"--desc DESC\" \"Project description - if not given will be taken from project.clj\" ] [ \"-a\" \"--deps DEPS\" \"Project dependencies in the form <group1>:<artifact1>:<version1>;<group2>... If not given will be taken from project.clj\" ] [ \"-m\" \"--multi\" \"Generate each namespace documentation as a separate file\" :default true ] [ \"-l\" \"--leiningen\" \"Generate the documentation for a Leiningen project file.\" ] [ \"-e\" \"--exclude EXCLUDE\" \"Exclude source file(s) from the document generation process <file1>;<file2>... If not given will be taken from project.clj\" ] [ \"-h\" \"--help\" \"Show this help\" ]])","title":"cli-opts"},{"location":"marginalia-md/core/#run-marginalia-md","text":"Default generation: given a collection of filepaths in a project, find the .clj files at these paths and, if Clojure source files are found: Print out a message to std out letting a user know which files are to be processed; Create the docs directory inside the project folder if it doesn't already exist; Call the uberdoc! function to generate the output file at its default location, using the found source files and a project file expected to be in its default location. If no source files are found, complain with a usage message. (defn) ( defn run-marginalia-md [ & args ] ( let [ user-parsed-options ( parse-opts args cli-opts ) { :keys [ dir file name version desc deps multi leiningen exclude arguments help ]} ( :options user-parsed-options ) files arguments sources ( distinct ( mc/format-sources ( seq files ))) sources ( if leiningen ( cons leiningen sources ) sources )] ( when help ( println ( :summary user-parsed-options ))) ( if ( and sources ( not help )) ( binding [ *docs* dir ] ( let [ project-clj ( when ( .exists ( io/file \"project.clj\" )) ( mc/parse-project-file )) choose # ( or %1 %2 ) marg-opts ( merge-with choose { :exclude ( when exclude ( .split exclude \";\" )) :leiningen leiningen } ( :marginalia project-clj )) opts ( merge-with choose { :name name :version version :description desc :dependencies ( mc/split-deps deps ) :multi multi :marginalia marg-opts } project-clj ) sources ( ->> sources ( filter # ( not ( mc/source-excluded? % opts ))) ( into []))] ( println \"Generating Marginalia documentation for the following source files:\" ) ( doseq [ s sources ] ( println \" \" s )) ( println ) ( mc/ensure-directory! *docs* ) ( if multi ( marginalia-md.markdown/multidoc! *docs* sources opts ) ( marginalia-md.markdown/uberdoc! ( str *docs* \"/\" file ) sources opts )) ( println \"Done generating your documentation in\" *docs* ) ( println \"\" ))) ( when-not help ( println \"Wrong number of arguments passed to Marginalia.\" ) ( println ( :summary user-parsed-options ))))))","title":"run-marginalia-md"},{"location":"marginalia-md/core/#-main","text":"(defn) ( defn -main [ & args ] ( apply run-marginalia-md args ))","title":"-main"},{"location":"marginalia-md/markdown/","text":"marginalia-md.markdown \u00b6 Utilities for parsing code into markdown (ns) ( ns marginalia-md.markdown ( :require [ clojure.java.io ] [ clojure.string :as str ] [ clojure.tools.reader ] [ marginalia.parser :as p ])) path-to-doc \u00b6 (defn) ( defn path-to-doc [ fn ] { :ns ( p/parse-ns ( java.io.File. fn )) :groups ( p/parse-file fn )}) code-block \u00b6 Create code block from given string s (defn-) ( defn- code-block ([ s ] ( code-block s 4 )) ([ s indent ] ( let [ indent-space ( str/join \"\" ( repeat indent \" \" ))] ( str indent-space \"```clojure\\n\" ( str/join \"\\n\" ( map # ( str indent-space % ) ( str/split s # \"\\n\" ))) \"\\n\" indent-space \"```\\n\\n\" )))) render-def-form \u00b6 (defn) ( defn render-def-form [{ :keys [ docstring raw forms level verb ] :or { level 2 }}] ( str ( str/join ( repeat level \"#\" )) \" \" ( second forms ) \"\\n\\n\" ( when docstring ( str docstring \"\\n\\n\" )) \"???+ tip \\\"(\" verb \")\\\"\\n\" ( code-block raw ))) render-form \u00b6 (defmulti) ( defmulti render-form ( fn [{ :keys [ type verb ]}] ( case type :comment [ :comment ] :code [ :code verb ] :default ))) render-form :default \u00b6 (defmethod) ( defmethod render-form :default [{ :keys [ docstring raw ]}] ( str docstring \"\\n\\n\" ( code-block raw ))) render-form [:code ns] \u00b6 (defmethod) ( defmethod render-form [ :code 'ns ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form ( assoc m :level 1 ))) render-form [:code def] \u00b6 (defmethod) ( defmethod render-form [ :code 'def ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m )) render-form [:code defn] \u00b6 (defmethod) ( defmethod render-form [ :code 'defn ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m )) render-form [:code defn-] \u00b6 (defmethod) ( defmethod render-form [ :code 'defn- ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m )) render-form [:code defmacro] \u00b6 (defmethod) ( defmethod render-form [ :code 'defmacro ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m )) render-form [:code defmulti] \u00b6 (defmethod) ( defmethod render-form [ :code 'defmulti ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m )) render-form [:code defmethod] \u00b6 (defmethod) ( defmethod render-form [ :code 'defmethod ] [{ :keys [ docstring raw forms verb method-value ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" ( eval method-value ) \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) \"???+ info \\\"(\" verb \")\\\"\\n\" ( code-block raw ))) render-form [:comment] \u00b6 (defmethod) ( defmethod render-form [ :comment ] [{ :keys [ docstring raw forms ] :as m }] ( if ( str/starts-with? raw \"=>\" ) ( str \"Result:\" ( code-block raw )) ( str raw \"\\n\\n\" ))) This is a comment Result: clojure => (+ 2 2) raw->forms \u00b6 (defn) ( defn raw->forms [ raw ] ( binding [ clojure.tools.reader/*read-eval* false ] ( let [ forms ( clojure.tools.reader/read-string raw ) multimethod? ( = ( first forms ) 'defmethod )] { :forms forms :verb ( first forms ) :var ( second forms ) :args ( if multimethod? ( get forms 3 ) ( get forms 2 )) :method-value ( when multimethod? ( nth forms 2 ))}))) comment here save-md \u00b6 Save markdown built from clojure source. (defn) ( defn save-md [ filename options ] ( let [ target ( :target options ( str ( second ( re-find # \"(.*)\\.(\\w+)$\" filename )) \".md\" ))] ( clojure.java.io/make-parents target ) ( when-not ( :append options ) ( spit target \"\" )) ( doseq [{ :keys [ raw type ] :as all } ( p/parse-file filename )] ( let [ all ( cond-> all ( and ( = type :code ) ( :raw all )) ( merge ( raw->forms raw )) :always identity )] ( spit target ( render-form all ) :append true ))))) multidoc! \u00b6 Generate an output file for each of provided namespace. (defn) ( defn multidoc! [ docs files options ] ( doseq [ filename files ] ( println filename ) ( let [ file-ns ( path-to-doc filename ) target-filename ( str docs \"/\" ( str/replace ( :ns file-ns ) # \"\\.\" \"/\" ) \".md\" )] ( save-md filename ( assoc options :target target-filename ))))) uberdoc! \u00b6 (defn) ( defn uberdoc! [ docs files options ] ( doseq [ filename files ] ( save-md filename ( assoc options :append true :target docs ))))","title":"marginalia-md.markdown"},{"location":"marginalia-md/markdown/#marginalia-mdmarkdown","text":"Utilities for parsing code into markdown (ns) ( ns marginalia-md.markdown ( :require [ clojure.java.io ] [ clojure.string :as str ] [ clojure.tools.reader ] [ marginalia.parser :as p ]))","title":"marginalia-md.markdown"},{"location":"marginalia-md/markdown/#path-to-doc","text":"(defn) ( defn path-to-doc [ fn ] { :ns ( p/parse-ns ( java.io.File. fn )) :groups ( p/parse-file fn )})","title":"path-to-doc"},{"location":"marginalia-md/markdown/#code-block","text":"Create code block from given string s (defn-) ( defn- code-block ([ s ] ( code-block s 4 )) ([ s indent ] ( let [ indent-space ( str/join \"\" ( repeat indent \" \" ))] ( str indent-space \"```clojure\\n\" ( str/join \"\\n\" ( map # ( str indent-space % ) ( str/split s # \"\\n\" ))) \"\\n\" indent-space \"```\\n\\n\" ))))","title":"code-block"},{"location":"marginalia-md/markdown/#render-def-form","text":"(defn) ( defn render-def-form [{ :keys [ docstring raw forms level verb ] :or { level 2 }}] ( str ( str/join ( repeat level \"#\" )) \" \" ( second forms ) \"\\n\\n\" ( when docstring ( str docstring \"\\n\\n\" )) \"???+ tip \\\"(\" verb \")\\\"\\n\" ( code-block raw )))","title":"render-def-form"},{"location":"marginalia-md/markdown/#render-form","text":"(defmulti) ( defmulti render-form ( fn [{ :keys [ type verb ]}] ( case type :comment [ :comment ] :code [ :code verb ] :default )))","title":"render-form"},{"location":"marginalia-md/markdown/#render-form-default","text":"(defmethod) ( defmethod render-form :default [{ :keys [ docstring raw ]}] ( str docstring \"\\n\\n\" ( code-block raw )))","title":"render-form :default"},{"location":"marginalia-md/markdown/#render-form-code-ns","text":"(defmethod) ( defmethod render-form [ :code 'ns ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form ( assoc m :level 1 )))","title":"render-form [:code ns]"},{"location":"marginalia-md/markdown/#render-form-code-def","text":"(defmethod) ( defmethod render-form [ :code 'def ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m ))","title":"render-form [:code def]"},{"location":"marginalia-md/markdown/#render-form-code-defn","text":"(defmethod) ( defmethod render-form [ :code 'defn ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m ))","title":"render-form [:code defn]"},{"location":"marginalia-md/markdown/#render-form-code-defn-","text":"(defmethod) ( defmethod render-form [ :code 'defn- ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m ))","title":"render-form [:code defn-]"},{"location":"marginalia-md/markdown/#render-form-code-defmacro","text":"(defmethod) ( defmethod render-form [ :code 'defmacro ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m ))","title":"render-form [:code defmacro]"},{"location":"marginalia-md/markdown/#render-form-code-defmulti","text":"(defmethod) ( defmethod render-form [ :code 'defmulti ] [{ :keys [ docstring raw forms ] :as m }] ( render-def-form m ))","title":"render-form [:code defmulti]"},{"location":"marginalia-md/markdown/#render-form-code-defmethod","text":"(defmethod) ( defmethod render-form [ :code 'defmethod ] [{ :keys [ docstring raw forms verb method-value ] :as m }] ( str ( str/join ( repeat 3 \"#\" )) \" \" ( second forms ) \" \" ( eval method-value ) \"\\n\" \"\\n\" ( when docstring ( str docstring \"\\n\\n\" )) \"???+ info \\\"(\" verb \")\\\"\\n\" ( code-block raw )))","title":"render-form [:code defmethod]"},{"location":"marginalia-md/markdown/#render-form-comment","text":"(defmethod) ( defmethod render-form [ :comment ] [{ :keys [ docstring raw forms ] :as m }] ( if ( str/starts-with? raw \"=>\" ) ( str \"Result:\" ( code-block raw )) ( str raw \"\\n\\n\" ))) This is a comment Result: clojure => (+ 2 2)","title":"render-form [:comment]"},{"location":"marginalia-md/markdown/#raw-forms","text":"(defn) ( defn raw->forms [ raw ] ( binding [ clojure.tools.reader/*read-eval* false ] ( let [ forms ( clojure.tools.reader/read-string raw ) multimethod? ( = ( first forms ) 'defmethod )] { :forms forms :verb ( first forms ) :var ( second forms ) :args ( if multimethod? ( get forms 3 ) ( get forms 2 )) :method-value ( when multimethod? ( nth forms 2 ))}))) comment here","title":"raw-&gt;forms"},{"location":"marginalia-md/markdown/#save-md","text":"Save markdown built from clojure source. (defn) ( defn save-md [ filename options ] ( let [ target ( :target options ( str ( second ( re-find # \"(.*)\\.(\\w+)$\" filename )) \".md\" ))] ( clojure.java.io/make-parents target ) ( when-not ( :append options ) ( spit target \"\" )) ( doseq [{ :keys [ raw type ] :as all } ( p/parse-file filename )] ( let [ all ( cond-> all ( and ( = type :code ) ( :raw all )) ( merge ( raw->forms raw )) :always identity )] ( spit target ( render-form all ) :append true )))))","title":"save-md"},{"location":"marginalia-md/markdown/#multidoc","text":"Generate an output file for each of provided namespace. (defn) ( defn multidoc! [ docs files options ] ( doseq [ filename files ] ( println filename ) ( let [ file-ns ( path-to-doc filename ) target-filename ( str docs \"/\" ( str/replace ( :ns file-ns ) # \"\\.\" \"/\" ) \".md\" )] ( save-md filename ( assoc options :target target-filename )))))","title":"multidoc!"},{"location":"marginalia-md/markdown/#uberdoc","text":"(defn) ( defn uberdoc! [ docs files options ] ( doseq [ filename files ] ( save-md filename ( assoc options :append true :target docs ))))","title":"uberdoc!"}]}